SET WARP_THRESHOLDS TO LIST(10, 20, 100, 400, 2000, 40000, 400000, 200000000).

DECLARE FUNCTION WARP_FOR {
	DECLARE PARAMETER N_SECS.
	SET START_TIME TO TIME:SECONDS.
	IF WARPMODE = "RAILS" {
		UNTIL TIME:SECONDS - START_TIME > N_SECS {
			SET T_LEFT TO N_SECS - (TIME:SECONDS - START_TIME).
			FOR VAL IN LIST(1,2,3,4,5,6,7) {
				IF T_LEFT < WARP_THRESHOLDS[VAL] OR VAL = 7 {
					SET WARP TO VAL.
					BREAK.
				}
			}
		}
		SET WARP TO 0.
	}
}

DECLARE FUNCTION PERFORM_BURN {
	DECLARE PARAMETER DV_BURN.

	SET THR TO 0.

	LOCK THROTTLE TO THR.

	SET START_TIME TO TIME:SECONDS.
	SET DV_LEFT TO MAX(DV_BURN, -DV_BURN).
	SET ACC TO SHIP:AVAILABLETHRUST/MASS.

	UNTIL DV_LEFT < 0 {
		IF (TIME:SECONDS - START_TIME) > 0 {
			UPDATE_STEERING().
			SET ACC TO SHIP:AVAILABLETHRUST/MASS.
			SET DV_LEFT TO DV_LEFT - ACC * THR * (TIME:SECONDS - START_TIME).
			SET THR TO MAX(MIN(DV_LEFT/ACC, 1),0.1).
			SET START_TIME TO TIME:SECONDS.
		}
	}

	SET THR TO 0.
}

DECLARE FUNCTION DROP_DEAD_ENGINES {
	LIST ENGINES IN EngList.
	SET FlameOut TO 0.
	SET AnyOn TO 0.
	FOR Eng IN EngList {
		IF Eng:FLAMEOUT {
			SET FlameOut TO FlameOut + 1.
		}
		IF Eng:IGNITION {
			SET AnyOn TO 1.
		}
	}

	IF FlameOut > 0 {
		PRINT "One or more engines have exhausted their fuel.".
		PRINT "Initiating next stage.".
		STAGE.
	} ELSE IF AnyOn = 0 {
		PRINT "There are no active engines!".
		PRINT "Initiating next stage.".
		STAGE.
	}
}

DECLARE FUNCTION FORWARD{
	RETURN VECTOREXCLUDE(UP:VECTOR, PROGRADE:VECTOR):DIRECTION.
}

DECLARE FUNCTION BACKWARD{
	RETURN VECTOREXCLUDE(UP:VECTOR, RETROGRADE:VECTOR):DIRECTION.
}

DECLARE FUNCTION LEFT{
	RETURN VCRS(UP:VECTOR, FORWARD():VECTOR):DIRECTION.
}

DECLARE FUNCTION RIGHT{
	RETURN VCRS(FORWARD():VECTOR, UP:VECTOR):DIRECTION.
}

DECLARE FUNCTION AIM_FOR_ORBIT {
	DECLARE PARAMETER DESIRED_ALTITUDE.
	DECLARE PARAMETER SOFTNESS.

	SET STEERING_ANGLE TO -MIN(MAX(90.0 - ((DESIRED_ALTITUDE - APOAPSIS)/SOFTNESS), 1),179.0).

	IF STEERING_ANGLE < 90.1 {
		LOCK STEERING TO UP + R(0, STEERING_ANGLE, 0).
	} ELSE {
		LOCK GLOBAL_STEERING TO UP + R(0, STEERING_ANGLE, 0).
		UPDATE_STEERING().
	}
}

DECLARE FUNCTION THROTTLE_FOR_ATMOSPHERE {
	DECLARE PARAMETER SOFTNESS.

	IF ALTITUDE > 70000{
		LOCK THROTTLE TO 1.0.
	} ELSE {
		SET TARGET_VEL TO ALTITUDE * ALTITUDE * 0.000001321 - ALTITUDE * 0.000813 + 277.496.

		LOCK THROTTLE TO MAX(MIN(1, (TARGET_VEL - AIRSPEED)/SOFTNESS), 0).
	}
}

DECLARE FUNCTION REAL_APOAPSIS{
	RETURN APOAPSIS + BODY:RADIUS.
}

DECLARE FUNCTION REAL_PERIAPSIS{
	RETURN PERIAPSIS + BODY:RADIUS.
}

DECLARE FUNCTION CALC_SEMI_MAJOR_AXIS {
	DECLARE PARAMETER INPUT_APOAPSIS.
	DECLARE PARAMETER INPUT_PERIAPSIS.
	RETURN (INPUT_APOAPSIS + INPUT_PERIAPSIS)/2.
}

DECLARE FUNCTION CALC_ECCENTRICITY {
	DECLARE PARAMETER INPUT_APOAPSIS.
	DECLARE PARAMETER INPUT_PERIAPSIS.
	RETURN (MAX(INPUT_APOAPSIS, INPUT_PERIAPSIS) - MIN(INPUT_APOAPSIS, INPUT_PERIAPSIS))/(INPUT_PERIAPSIS + INPUT_APOAPSIS).
}

DECLARE FUNCTION APOAPSIS_SPEED {
	DECLARE PARAMETER INPUT_APOAPSIS.
	DECLARE PARAMETER INPUT_PERIAPSIS.
	SET ECC TO CALC_ECCENTRICITY(INPUT_APOAPSIS, INPUT_PERIAPSIS).
	RETURN SQRT((1 - ECC) * BODY:MU / ((1 + ECC) * CALC_SEMI_MAJOR_AXIS(INPUT_PERIAPSIS, INPUT_APOAPSIS))).
}

DECLARE FUNCTION PERIAPSIS_SPEED {
	DECLARE PARAMETER INPUT_APOAPSIS.
	DECLARE PARAMETER INPUT_PERIAPSIS.
	SET ECC TO CALC_ECCENTRICITY(INPUT_APOAPSIS, INPUT_PERIAPSIS).
	RETURN SQRT((1 + ECC) * BODY:MU / ((1 - ECC) * CALC_SEMI_MAJOR_AXIS(INPUT_PERIAPSIS, INPUT_APOAPSIS))).
}

DECLARE FUNCTION ROUGH_BURN_DURATION_FOR_DELTA_V{
	DECLARE PARAMETER DELTA_V.
	SET M TO MASS.
	SET DM TO 0.

	LIST ENGINES IN EngList.

	FOR Eng in EngList {
		IF Eng:IGNITION {
			SET DM TO DM + Eng:MAXTHRUST/(Eng:VISP * 9.81).
		}
	}

	RETURN (M - constant():e ^ (LN(M) - DELTA_V * DM / MAXTHRUST))/DM.
}

DECLARE FUNCTION DELTA_V_TO_ACHIEVE_PERIAPSIS {
	DECLARE PARAMETER DESIRED_PERIAPSIS.
	IF DESIRED_PERIAPSIS < REAL_APOAPSIS {
		RETURN APOAPSIS_SPEED(REAL_APOAPSIS,  DESIRED_PERIAPSIS) - APOAPSIS_SPEED(REAL_APOAPSIS, REAL_PERIAPSIS).
	}
	RETURN PERIAPSIS_SPEED(REAL_APOAPSIS,  DESIRED_PERIAPSIS) - APOAPSIS_SPEED(REAL_APOAPSIS, REAL_PERIAPSIS).
}

DECLARE FUNCTION DELTA_V_TO_ACHIEVE_APOAPSIS {
	DECLARE PARAMETER DESIRED_APOAPSIS.
	IF DESIRED_APOAPSIS > REAL_PERIAPSIS {
		RETURN PERIAPSIS_SPEED(DESIRED_APOAPSIS, REAL_PERIAPSIS)- PERIAPSIS_SPEED(REAL_APOAPSIS, REAL_PERIAPSIS).
	}
	RETURN APOAPSIS_SPEED(DESIRED_APOAPSIS, REAL_PERIAPSIS)- PERIAPSIS_SPEED(REAL_APOAPSIS, REAL_PERIAPSIS).
}

DECLARE FUNCTION ALTER_PERIAPSIS_TO {
	DECLARE PARAMETER DESIRED_PERIAPSIS.

	SET DV TO DELTA_V_TO_ACHIEVE_PERIAPSIS(DESIRED_PERIAPSIS + BODY:RADIUS).

	SET BURN_DURATION TO ROUGH_BURN_DURATION_FOR_DELTA_V(MAX(DV, -DV)).

	WARP_FOR(ETA:APOAPSIS - BURN_DURATION - 50).

	LOCK GLOBAL_STEERING TO FORWARD().
	IF DV < 0 {
		LOCK GLOBAL_STEERING TO BACKWARD().
	}

	PRINT "Waiting " + (ETA:APOAPSIS - MAX(BURN_DURATION/2, 1)) + "s to let the ship stabilize.".

	UNTIL ETA:APOAPSIS < MAX(BURN_DURATION/2, 1){
		UPDATE_STEERING().
	}

	PERFORM_BURN(DV).

	PRINT "Periapsis should now be:".
	PRINT DESIRED_PERIAPSIS.
	
	WAIT 0.1.
}


DECLARE FUNCTION ALTER_APOAPSIS_TO {
	DECLARE PARAMETER DESIRED_APOAPSIS.

	SET DV TO DELTA_V_TO_ACHIEVE_APOAPSIS(DESIRED_APOAPSIS + BODY:RADIUS).

	SET BURN_DURATION TO ROUGH_BURN_DURATION_FOR_DELTA_V(MAX(DV, -DV)).

	PRINT "TRYING TO ACHIEVE DV OF:".
	PRINT DV.

	WARP_FOR(ETA:PERIAPSIS - BURN_DURATION - 50).

	LOCK GLOBAL_STEERING TO FORWARD().

	IF DV < 0 {
		LOCK GLOBAL_STEERING TO BACKWARD().
	}

	PRINT "Waiting " + (ETA:PERIAPSIS - MAX(BURN_DURATION/2, 1)) + "s to let the ship stabilize.".

	UNTIL ETA:PERIAPSIS < MAX(BURN_DURATION/2, 1){
		UPDATE_STEERING().
	}

	PERFORM_BURN(DV).

	PRINT "Apoapsis should now be:".
	PRINT DESIRED_APOAPSIS.
	
	WAIT 0.1.
}

LOCK GLOBAL_STEERING TO UP.

SET D_STRENGTH TO 4.
SET P_STRENGTH TO 4.
SET BOUNDS TO 1.
SET GOOD_ENOUGH TO 0.01.

DECLARE FUNCTION UPDATE_STEERING
{
	SET SHIP_FORWARD TO SHIP:FACING:FOREVECTOR.
	SET SHIP_UP TO SHIP:FACING:UPVECTOR.
	SET SHIP_RIGHT TO SHIP:FACING:RIGHTVECTOR.

	SET SHIP_ROLL TO SHIP_FORWARD * SHIP:ANGULARVEL.
	SET SHIP_YAW TO SHIP_UP * SHIP:ANGULARVEL.
	SET SHIP_PITCH TO SHIP_RIGHT * SHIP:ANGULARVEL.

	SET DIFF_VECTOR TO VCRS(SHIP:FACING:VECTOR, GLOBAL_STEERING:VECTOR).

	IF VCRS(SHIP_UP, GLOBAL_STEERING:UPVECTOR) * SHIP_FORWARD > 0
	{
		SET DESIRED_ROLL TO -VECTORANGLE(SHIP_UP, GLOBAL_STEERING:UPVECTOR)/180.
	} ELSE {
		SET DESIRED_ROLL TO VECTORANGLE(SHIP_UP, GLOBAL_STEERING:UPVECTOR)/180.
	}

	SET DESIRED_YAW TO SHIP_UP * DIFF_VECTOR.
	SET DESIRED_PITCH TO SHIP_RIGHT * DIFF_VECTOR.

	IF (DESIRED_YAW < GOOD_ENOUGH) AND (SHIP_YAW < GOOD_ENOUGH) AND (DESIRED_PITCH < GOOD_ENOUGH) AND (SHIP_PITCH < GOOD_ENOUGH) {
		SAS ON.
		LOCK STEERING TO GLOBAL_STEERING.
	} ELSE {
		SAS OFF.
		UNLOCK STEERING.
		SET SHIP_ROLL_AMOUNT TO (D_STRENGTH * SHIP_ROLL + DESIRED_ROLL * P_STRENGTH) /3.
		SET SHIP_YAW_AMOUNT TO -D_STRENGTH * SHIP_YAW + DESIRED_YAW * P_STRENGTH.
		SET SHIP_PITCH_AMOUNT TO D_STRENGTH * SHIP_PITCH - DESIRED_PITCH * P_STRENGTH.
		SET SHIP:CONTROL:ROTATION TO V(SHIP_YAW_AMOUNT, SHIP_PITCH_AMOUNT, SHIP_ROLL_AMOUNT).
	}
}

DECLARE FUNCTION TOUCHDOWN
{
	LOCK GLOBAL_STEERING TO SHIP:SRFRETROGRADE.
	LOCK THROTTLE TO 1.
	UNTIL ALT:RADAR < 3 {
		SET DECELERATION_AVAILABLE TO (SHIP:MAXTHRUST / SHIP:MASS) - SHIP:BODY:MU / ((ALTITUDE + BODY:RADIUS) * (ALTITUDE + BODY:RADIUS)).
		SET DESIRED_SPEED TO SQRT(ALT:RADAR / DECELERATION_AVAILABLE).

		PRINT DESIRED_SPEED.

		IF VELOCITY:SURFACE:MAG > DESIRED_SPEED{
			LOCK THROTTLE TO MAX(MIN(1, (VELOCITY:SURFACE:MAG - DESIRED_SPEED)/2), 0).
			PRINT "Locking throttle to " + MAX(MIN(1, (VELOCITY:SURFACE:MAG - DESIRED_SPEED)/40), 0).
		} ELSE {
			LOCK THROTTLE TO 0.0.
		}
		UPDATE_STEERING().
		WAIT 0.1.
	}
	SAS ON.
	LOCK THROTTLE TO 0.0.
}
